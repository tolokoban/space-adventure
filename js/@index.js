/**********************************************************************
 require( 'require' )
 -----------------------------------------------------------------------
 @example

 var Path = require("node://path");  // Only in NodeJS/NW.js environment.
 var Button = require("tfw.button");

 **********************************************************************/

window.require = function() {
    var modules = {};
    var definitions = {};
    var nodejs_require = typeof window.require === 'function' ? window.require : null;

    var f = function(id, body) {
        if( id.substr( 0, 7 ) == 'node://' ) {
            // Calling for a NodeJS module.
            if( !nodejs_require ) {
                throw Error( "[require] NodeJS is not available to load module `" + id + "`!" );
            }
            return nodejs_require( id.substr( 7 ) );
        }

        if( typeof body === 'function' ) {
            definitions[id] = body;
            return;
        }
        var mod;
        body = definitions[id];
        if (typeof body === 'undefined') {
            var err = new Error("Required module is missing: " + id);   
            console.error(err.stack);
            throw err;
        }
        mod = modules[id];
        if (typeof mod === 'undefined') {
            mod = {exports: {}};
            var exports = mod.exports;
            body(f, mod, exports);
            modules[id] = mod.exports;
            mod = mod.exports;
            //console.log("Module initialized: " + id);
        }
        return mod;
    };
    return f;
}();
function addListener(e,l) {
    if (window.addEventListener) {
        window.addEventListener(e,l,false);
    } else {
        window.attachEvent('on' + e, l);
    }
};

addListener(
    'DOMContentLoaded',
    function() {
        document.body.parentNode.$data = {};
        // Attach controllers.
        APP = require('app');
setTimeout(function (){if(typeof APP.start==='function')APP.start()});

    }
);
require("$",function(n,r,a){a.config={name:'"space-adventure"',description:'"WebGL clone of Cavalcadeur\'s original game."',author:'"tolokoban"',version:'"0.0.50"',major:"0",minor:"0",revision:"50",date:"2022-01-25T14:25:23.000Z",consts:{}};var o=null;a.lang=function(n){return void 0===n&&(window.localStorage&&(n=window.localStorage.getItem("Language")),n||(n=window.navigator.language)||(n=window.navigator.browserLanguage)||(n="fr"),n=n.substr(0,2).toLowerCase()),o=n,window.localStorage&&window.localStorage.setItem("Language",n),n},a.intl=function(n,r){var o,e,t,i,g,l,u,s=n[a.lang()],c=r[0];for(u in n)break;if(!u)return c;if(!s&&!(s=n[u]))return c;if(o=s[c],o||(s=n[u],o=s[c]),!o)return c;if(r.length>1){for(e="",g=0,t=0;t<o.length;t++)i=o.charAt(t),"$"===i?(e+=o.substring(g,t),t++,l=o.charCodeAt(t)-48,l<0||l>=r.length?e+="$"+o.charAt(t):e+=r[l],g=t+1):"\\"===i&&(e+=o.substring(g,t),t++,e+=o.charAt(t),g=t+1);e+=o.substr(g),o=e}return o}});
//# sourceMappingURL=$.js.map
require("app",function(e,n,r){var t=function(){function n(){return t(r,arguments)}var r={en:{},fr:{}},t=e("$").intl;return n.all=r,n}();e("offline");var i=e("tfw.webgl"),o=e("alert"),a=e("play"),s=e("$").config,c=document.getElementById("canvas"),l=new i.Renderer(c);a.init(l.gl,c).then(function(){a.reset(),l.start(function(e){var n=window.innerHeight>800?1:0,r=window.innerWidth>>n,t=window.innerHeight>>n;c.setAttribute("width",r),c.setAttribute("height",t),l.gl.viewport(0,0,r,t),a.draw(e)})}),o("Quick slides up and down to move your spaceship.<br/>Or use the keyboard's arrow keys.<p>"+s.version+"</p>",a.start.bind(a));var d=screen.lockOrientationUniversal||screen.mozLockOrientationUniversal||screen.msLockOrientationUniversal;d&&(console.log("Trying to lock the screen in landscape mode."),d("landscape-primary")),n.exports._=t});
//# sourceMappingURL=app.js.map
require("play",function(e,r,t){function a(){n.disable(n.DEPTH_TEST),n.enable(n.BLEND),n.clearColor(28/255,34/255,67/255,1),n.clear(n.COLOR_BUFFER_BIT)}var n,E,T,o=function(){function r(){return a(t,arguments)}var t={en:{},fr:{}},a=e("$").intl;return r.all=t,r}(),i=e("global"),_=e("hero"),R=e("moon"),u=e("stars"),m=e("explo"),c=e("smoke"),d=(e("tfw.webgl"),e("image-loader")),l=(e("event-handler"),0);t.init=function(e,r){return l=0,n=e,E=r,new Promise(function(e,r){d({hero:"hero.png",moon:"moon.png",earth:"earth.png"}).then(function(r){T=document.createElement("canvas"),T.setAttribute("width",512),T.setAttribute("height",512);var t=T.getContext("2d");t.drawImage(r.hero,0,0,256,256),t.drawImage(r.moon,256,0,256,256),t.drawImage(r.earth,0,256,256,256),e()})})},t.start=function(){_.start()},t.reset=function(){l=0,_.reset(n),R.reset(n),c.reset(n),u.reset(n),m.reset(n);var e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,T)},t.draw=function(e){if(n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),e*=.001,0==l)return void(l=e);l=e,_.move(e),R.move(e),i.cameraX=_.x(),i.cameraY=.5*i.COL_H,a(),u.draw(e),R.draw(e),_.draw(e),c.draw(e),m.draw(e)},r.exports._=o});
//# sourceMappingURL=play.js.map
require("event-handler",function(n,e,t){var o=function(){function e(){return o(t,arguments)}var t={en:{},fr:{}},o=n("$").intl;return e.all=t,e}(),i=function(){},c=!1;e.exports={on:function(n){i=n},start:function(){c=!0},stop:function(){c=!1}},document.addEventListener("keydown",function(n){c&&(38==n.keyCode?i(1):40==n.keyCode&&i(-1))});var r,u,a;document.addEventListener("touchstart",function(n){var e=n.changedTouches[0];r=e.clientX,u=e.clientY,a=Date.now()}),document.addEventListener("touchmove",function(n){var e=n.changedTouches[0],t=e.clientX-r,o=e.clientY-u;(t>0?t:-t)>(o>0?o:-o)&&i(0);var c=(o>0?o:-o)/((Date.now()-a)*window.innerHeight);return c*=1e3,c=Math.min(2,c<1?1:c),o<0?i(+c):o>0?i(-c):(r=e.clientX,u=e.clientY,void(a=Date.now()))}),e.exports._=o});
//# sourceMappingURL=event-handler.js.map
require("image-loader",function(n,r,e){var o=function(){function r(){return o(e,arguments)}var e={en:{},fr:{}},o=n("$").intl;return r.all=e,r}();n("polyfill.promise"),r.exports=function(n){return new Promise(function(r,e){var o,i,t,s,l,u={},a=0,c=function(){0==--a&&r(u)},f=function(n){console.error("Unable to load image "+this.src+"! ",n),u[this.$id]=n,c()};for(o in n)i="css/app/"+n[o],t=i.substr(0,i.length-4),s=i.substr(i.length-4),a++,l=new Image,l.$id=o,u[o]=l,l.onload=c,l.onerror=f,l.src=i,l.srcset=t+".mini"+s+" 640w, "+i})},r.exports._=o});
//# sourceMappingURL=image-loader.js.map
require("polyfill.promise",function(t,n,e){var r=function(){function n(){return r(e,arguments)}var e={en:{},fr:{}},r=t("$").intl;return n.all=e,n}();window.Promise||function(){"use strict";function t(t){return"function"==typeof t||"object"==typeof t&&null!==t}function n(t){return"function"==typeof t}function e(t){return"object"==typeof t&&null!==t}function r(){}function o(){for(var t=0;t<S;t+=2){(0,D[t])(D[t+1]),D[t]=void 0,D[t+1]=void 0}S=0}function i(){}function s(){return new TypeError("You cannot resolve a promise with itself")}function u(){return new TypeError("A promises callback cannot return that same promise.")}function c(t){try{return t.then}catch(t){return K.error=t,K}}function a(t,n,e,r){try{t.call(n,e,r)}catch(t){return t}}function f(t,n,e){C(function(t){var r=!1,o=a(e,n,function(e){r||(r=!0,n!==e?_(t,e):v(t,e))},function(n){r||(r=!0,d(t,n))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,d(t,o))},t)}function l(t,n){n._state===q?v(t,n._result):t._state===F?d(t,n._result):y(n,void 0,function(n){_(t,n)},function(n){d(t,n)})}function h(t,e){if(e.constructor===t.constructor)l(t,e);else{var r=c(e);r===K?d(t,K.error):void 0===r?v(t,e):n(r)?f(t,e,r):v(t,e)}}function _(n,e){n===e?d(n,s()):t(e)?h(n,e):v(n,e)}function p(t){t._onerror&&t._onerror(t._result),m(t)}function v(t,n){t._state===I&&(t._result=n,t._state=q,0===t._subscribers.length||C(m,t))}function d(t,n){t._state===I&&(t._state=F,t._result=n,C(p,t))}function y(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+q]=e,o[i+F]=r,0===i&&t._state&&C(m,t)}function m(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,s=0;s<n.length;s+=3)r=n[s],o=n[s+e],r?g(e,r,o,i):o(i);t._subscribers.length=0}}function w(){this.error=null}function b(t,n){try{return t(n)}catch(t){return N.error=t,N}}function g(t,e,r,o){var i,s,c,a,f=n(r);if(f){if(i=b(r,o),i===N?(a=!0,s=i.error,i=null):c=!0,e===i)return void d(e,u())}else i=o,c=!0;e._state!==I||(f&&c?_(e,i):a?d(e,s):t===q?v(e,i):t===F&&d(e,i))}function A(t,n){try{n(function(n){_(t,n)},function(n){d(t,n)})}catch(n){d(t,n)}}function j(t,n,e,r){this._instanceConstructor=t,this.promise=new t(i,r),this._abortOnReject=e,this._validateInput(n)?(this._input=n,this.length=n.length,this._remaining=n.length,this._init(),0===this.length?v(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&v(this.promise,this._result))):d(this.promise,this._validationError())}function E(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function P(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function T(t,e){this._id=G++,this._label=e,this._state=void 0,this._result=void 0,this._subscribers=[],i!==t&&(n(t)||E(),this instanceof T||P(),A(this,t))}var k;k=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var M,O=k,S=(Date.now,Object.create,0),C=function(t,n){D[S]=t,D[S+1]=n,2===(S+=2)&&M()},R="undefined"!=typeof window?window:{},x=R.MutationObserver||R.WebKitMutationObserver,Y="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,D=new Array(1e3);M="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?function(){return function(){process.nextTick(o)}}():x?function(){var t=0,n=new x(o),e=document.createTextNode("");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}():Y?function(){var t=new MessageChannel;return t.port1.onmessage=o,function(){t.port2.postMessage(0)}}():function(){return function(){setTimeout(o,1)}}();var I=void 0,q=1,F=2,K=new w,N=new w;j.prototype._validateInput=function(t){return O(t)},j.prototype._validationError=function(){return new Error("Array Methods must be provided an Array")},j.prototype._init=function(){this._result=new Array(this.length)};var U=j;j.prototype._enumerate=function(){for(var t=this.length,n=this.promise,e=this._input,r=0;n._state===I&&r<t;r++)this._eachEntry(e[r],r)},j.prototype._eachEntry=function(t,n){var r=this._instanceConstructor;e(t)?t.constructor===r&&t._state!==I?(t._onerror=null,this._settledAt(t._state,n,t._result)):this._willSettleAt(r.resolve(t),n):(this._remaining--,this._result[n]=this._makeResult(q,n,t))},j.prototype._settledAt=function(t,n,e){var r=this.promise;r._state===I&&(this._remaining--,this._abortOnReject&&t===F?d(r,e):this._result[n]=this._makeResult(t,n,e)),0===this._remaining&&v(r,this._result)},j.prototype._makeResult=function(t,n,e){return e},j.prototype._willSettleAt=function(t,n){var e=this;y(t,void 0,function(t){e._settledAt(q,n,t)},function(t){e._settledAt(F,n,t)})};var W=function(t,n){return new U(this,t,!0,n).promise},$=function(t,n){function e(t){_(s,t)}function r(t){d(s,t)}var o=this,s=new o(i,n);if(!O(t))return d(s,new TypeError("You must pass an array to race.")),s;for(var u=t.length,c=0;s._state===I&&c<u;c++)y(o.resolve(t[c]),void 0,e,r);return s},z=function(t,n){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var r=new e(i,n);return _(r,t),r},B=function(t,n){var e=this,r=new e(i,n);return d(r,t),r},G=0,H=T;T.all=W,T.race=$,T.resolve=z,T.reject=B,T.prototype={constructor:T,then:function(t,n,e){var r=this,o=r._state;if(o===q&&!t||o===F&&!n)return this;r._onerror=null;var s=new this.constructor(i,e),u=r._result;if(o){var c=arguments[o-1];C(function(){g(o,s,c,u)})}else y(r,s,t,n);return s},catch:function(t,n){return this.then(null,t,n)}};var J=function(){var t;"Promise"in(t="undefined"!=typeof global?global:"undefined"!=typeof window&&window.document?window:self)&&"resolve"in t.Promise&&"reject"in t.Promise&&"all"in t.Promise&&"race"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),n(e)}()||(t.Promise=H)};J()}.call(this),n.exports._=r});
//# sourceMappingURL=polyfill.promise.js.map
require("tfw.webgl",function(e,r,t){function n(e,r,t){if("string"===(r.vert,!1))throw Error("[tfw.webgl.Program] Missing attribute `vert` in argument `codes`!");if("string"===(r.frag,!1))throw Error("[tfw.webgl.Program] Missing attribute `frag` in argument `codes`!");r=a(r,t);var n=e.createProgram();e.attachShader(n,s(e,r.vert||"//No Vertex Shader")),e.attachShader(n,c(e,r.frag||"//No Fragment Shader")),e.linkProgram(n),this.program=n,Object.freeze(this.program),this.use=function(){e.useProgram(n)},this.use();var u,f,m={},g=e.getProgramParameter(n,e.ACTIVE_ATTRIBUTES);for(u=0;u<g;u++)f=e.getActiveAttrib(n,u),m[f.name]=e.getAttribLocation(n,f.name),this["$"+f.name]=e.getAttribLocation(n,f.name);Object.freeze(m),this.attribs=m;var E={},T=e.getProgramParameter(n,e.ACTIVE_UNIFORMS);for(u=0;u<T;u++)f=e.getActiveUniform(n,u),E[f.name]=e.getUniformLocation(n,f.name),Object.defineProperty(this,"$"+f.name,{set:i(e,f,E[f.name]),get:o(f),enumerable:!0,configurable:!0});Object.freeze(E),this.uniforms=E}function a(e,r){var t,n,a={};for(t in e)n=e[t],a[t]=n.split("\n").map(function(e){if("#include"!=e.trim().substr(0,8))return e;var t=e.indexOf("#include")+8,n=e.substr(t).trim();"'<\"".indexOf(n.charAt(0))>-1&&(n=n.substr(1,n.length-2));var a=r[n];if("string"!=typeof a)throw console.error("Include <"+n+"> not found in ",r),Error("Include not found in shader: "+n);return a}).join("\n");return a}function i(e,r,t){var n="_$"+r.name;switch(r.type){case e.BYTE:case e.UNSIGNED_BYTE:case e.SHORT:case e.UNSIGNED_SHORT:case e.INT:case e.UNSIGNED_INT:return 1==r.size?function(r){e.uniform1i(t,r),this[n]=r}:function(r){e.uniform1iv(t,r),this[n]=r};case e.FLOAT:return 1==r.size?function(r){e.uniform1f(t,r),this[n]=r}:function(r){e.uniform1fv(t,r),this[n]=r}}}function o(e){var r="_$"+e.name;return function(){return this[r]}}function u(e,r,t){var n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),r.getShaderParameter(n,r.COMPILE_STATUS)?n:(console.log(t),console.error("An error occurred compiling the shader: "+r.getShaderInfoLog(n)),null)}function c(e,r){return u(e.FRAGMENT_SHADER,e,r)}function s(e,r){return u(e.VERTEX_SHADER,e,r)}var f=function(){function r(){return n(t,arguments)}var t={en:{},fr:{}},n=e("$").intl;return r.all=t,r}(),m=function(e){"string"==typeof e&&(e=document.getElementById(e)),Object.defineProperty(this,"canvas",{value:e,writable:!1,configurable:!1,enumerable:!0}),Object.defineProperty(this,"gl",{value:e.getContext("webgl")||e.getContext("experimental-webgl"),writable:!1,configurable:!1,enumerable:!0})};m.prototype.start=function(e){var r=function(t){window.requestAnimationFrame(r),e(t)};window.requestAnimationFrame(r)};var g=function(e,r,t){var n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,t,0,e.RGBA,e.UNSIGNED_BYTE,null),n},E=function(e){var r=e.width,t=e.height,n=document.createElement("canvas");n.setAttribute("width",r),n.setAttribute("height",t);var a=n.getContext("2d");return a.drawImage(e,0,0),a.getImageData(0,0,r,t).data};t.Renderer=m,t.Program=n,t.createTextureForFB=g,t.getDataFromImage=E,r.exports._=f});
//# sourceMappingURL=tfw.webgl.js.map
require("smoke",function(r,e,t){function n(r,e,t){R=r;var n=c*P;a[n++]=e-10,a[n++]=t-40,a[n++]=r,a[n++]=u(),a[n++]=Math.min(1,r-f.collisionTime()),P=(P+1)%s}var a,i,o,A=function(){function e(){return n(t,arguments)}var t={en:{},fr:{}},n=r("$").intl;return e.all=t,e}(),l=r("global"),u=r("random"),f=r("hero"),b=r("programs"),c=5,s=80,_=null,P=0,R=0;t.ready=new Promise(function(r,e){r()}),t.reset=function(r){_||(_=r,i=_.createBuffer(),o=b(_,"Smoke")),a=new Float32Array(c*s),i=_.createBuffer()},t.draw=function(r){_.blendFunc(_.SRC_ALPHA,_.ONE_MINUS_SRC_ALPHA),_.blendFuncSeparate(_.SRC_ALPHA,_.ONE_MINUS_SRC_ALPHA,_.ZERO,_.ONE),_.blendEquation(_.FUNC_ADD),r-R>.01&&n(r,f.x()-30*u(),f.y()-30*u()),l.setGlobalUniforms(o,r),o.$uniCollision=f.collisionTime(),_.bindBuffer(_.ARRAY_BUFFER,i),_.bufferData(_.ARRAY_BUFFER,a,_.STATIC_DRAW);var e=l.BPE*c;_.enableVertexAttribArray(o.$attPos),_.vertexAttribPointer(o.$attPos,4,_.FLOAT,!1,e,0),_.enableVertexAttribArray(o.$attLight),_.vertexAttribPointer(o.$attLight,1,_.FLOAT,!1,e,4*l.BPE),_.drawArrays(_.POINTS,0,s)},e.exports._=A});
//# sourceMappingURL=smoke.js.map
require("programs",function(n,o,a){var e=function(){function o(){return e(a,arguments)}var a={en:{},fr:{}},e=n("$").intl;return o.all=a,o}(),t={vertHero:"#include vertCommon\n#include game2gl  \n\n// Rotation in radians.\nuniform float uniRotation;\n\n// Vertex position and texture coords.\n// (x,y) for vertex position, in game's space.\n// (z,w) for (radius,angle).\nattribute vec4 attPos;\n\nvarying vec2 varUV;\n\nconst float SQRT2 = 1.4142135623730951;\n\nvoid main() {\n  float xG = attPos.x;\n  float yG = attPos.y;\n  // Diagonals must be multiplied by the square root of two.\n  float radius = attPos.z * SQRT2;\n  // Using the angle, we can deduce the corner position.\n  float angle = attPos.w;\n  // Propagate UV to the fragment shader.\n  varUV = vec2( .5 * SQRT2 * cos(angle) + .5,\n                .5 - .5 * SQRT2 * sin(angle) );\n  // Apply hero's self rotation.\n  angle += uniRotation;\n  // Adding some deformations due to \"Infinite Improbability Drive\".\n  angle *= 1.0 + .03 * cos(.6 * uniVTime * (.777+angle));\n  // Coords of this corner.\n  vec2 point = game2gl( xG + radius * cos(angle), yG + radius * sin(angle) );\n  \n  // GL has a square space with coords between -1 and +1.\n  // Final position in GL space.\n  gl_Position = vec4( point, 0.0, 1.0 );\n}\n",fragHero:"precision mediump float;\n// Current time.\nuniform float uniFTime;\n// Last collision time.\nuniform float uniCollision;\n// The texture is the hero image.\nuniform sampler2D uniTexture;\n// texture coords UV between 0 and +1.\nvarying vec2 varUV;\n\nvoid main() {\n  gl_FragColor = texture2D( uniTexture, .495 * varUV );\n  float collision = uniFTime - uniCollision;\n  if( collision < 1.0 ) {\n    gl_FragColor.g *= collision;\n    gl_FragColor.b *= collision;\n  }\n}\n",vertMoon:"#include vertCommon\n#include game2gl\n  \n// Vertex position and texture coords.\n// (x,y) for vertex position, in game's space.\n// (z,w) for (u,v) texture coords.\nattribute vec2 attPos;\n// Point size.\nattribute float attSize;\nattribute float attRnd1;\nattribute float attRnd2;\nattribute float attDeath;\n\nvarying float varSize;\nvarying float varRnd1;\nvarying float varRnd2;\nvarying float varDeath;\n\n\nvoid main() {\n  // Propagate size to the fragment shader.\n  varSize = attSize;\n  varRnd1 = attRnd1;\n  varRnd2 = attRnd2;\n  varDeath = attDeath;\n  // Game's space coords.\n  vec2 point = game2gl( attPos );\n  // GL has a square space with coords between -1 and +1.\n  // Final position in GL space.\n  gl_Position = vec4( point, 0.0, 1.0 );\n  // Point's size...\n  gl_PointSize = pointSize( attSize );\n}\n",fragMoon:"precision mediump float;\r\n\r\nconst float PI = 3.141592653589793;\r\n\r\nconst float X = .5;\r\nconst float Y = -.5;\r\nconst float Z = 0.7071067811865476;\r\n\r\nconst vec4 WHITE = vec4( 1.0, 1.0, 1.0, 1.0 );\r\nconst vec4 BLACK = vec4( 0.0, 0.0, 0.0, 1.0 );\r\nconst vec4 ORANGE = vec4( 1.0, 0.5, 0.0, 1.0 );\r\n\r\nuniform float uniFTime;\r\n\r\n// The texture is the hero image.\r\nuniform sampler2D uniTexture;\r\n\r\nvarying float varSize;\r\nvarying float varRnd1;\r\nvarying float varRnd2;\r\nvarying float varDeath;\r\n\r\n/**\r\n * To perform a sphere mapping, we must figure out (u,v) coords on the texture\r\n * from (x,y) from the PointCoord. We also must consider rotations of the sphere.\r\n * Step 1:\r\n *   Consider the hemi-sphere, and find out the vector (x,y,z).\r\n *   We already know x and y, and we also know that (x,y,z) have a length of 1.\r\n *   Hence, x*x + y*y + z*z = 1 and we can deduce z.\r\n * Step 2:\r\n *   Apply sphere rotation. This is a combination of two rotations: one around X axe\r\n *   and another one around Y axe.\r\n *   For instance, around X, we have:\r\n *     Y = y*cos(a) + z*sin(a)\r\n *     Z = -y*sin(a) + z*cos(a)\r\n *   The rotation formula are simple to memorize because the second expression\r\n *   can be deduced by derivation of the first one.\r\n * Step 3:\r\n *   Now we consider (X,Y). With asin(Y) we get the latitude between -PI/2 and +PI/2.\r\n *   The plane y=Y cuts the sphere in a disk of radius cos(lat). Hence, we get longitude\r\n *   by computing asin(X / cos(lat)).\r\n * Step 4:\r\n *   Of course, the longitude you get is between -PI/2 and +PI/2, but it is only valid\r\n *   if Z is positive. If Z is negative, you want to get a longitude between +PI/2 and\r\n *   +3.PI/2. And while for Z positive longitude increase with X, on Z negative it is reversed.\r\n * \r\n */\r\nvoid main() {\r\n  // Vector (x,y,z) has its tail at the center of the sphere and its head on the surface of the sphere.\r\n  float x = gl_PointCoord.x * 2.0 - 1.0;\r\n  float y = gl_PointCoord.y * 2.0 - 1.0;\r\n  float radius = x*x + y*y;\r\n  float alpha = 1.0;\r\n  if( radius > 1.0 ) {\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  if( radius > .9 ) {\r\n    alpha = 10.0 * (1.0 - radius);\r\n  }\r\n  // Therefore, the length of the (x,y,z) vector must be 1 and x*x + y*y + z*z = 1.\r\n  float z = sqrt( 1.0 - x*x - y*y );\r\n  // Rotation.\r\n  float a = uniFTime * .75 * (.2374 + varRnd1);\r\n  float x1 = x;\r\n  float y1 = y * cos(a) + z * sin(a);\r\n  float z1 = -y * sin(a) + z * cos(a);\r\n  a = uniFTime * .75 * (.3797 + varRnd2);\r\n  float x2 = x1 * cos(a) + z1 * sin(a);\r\n  float y2 = y1;\r\n  float z2 = -x1 * sin(a) + z1 * cos(a);\r\n  \r\n  float lat = -asin( y2 );\r\n  float r = cos( lat );\r\n  float lng = 0.0;\r\n  if( r > 0.0 ) {\r\n    lng = asin( x2 / r );\r\n  }\r\n  lng += PI * .5;   // Now lng is between 0 and PI.\r\n  if( z2 < .0 ) {\r\n    // We must adjust for the backface of the moon.\r\n    lng = 2.0 * PI - lng;\r\n  }  \r\n  \r\n  vec2 uv = vec2(.5 * lng / PI, .5 - lat / PI);\r\n  vec2 uvColor = .5 * uv + vec2(.0, .5);\r\n  //gl_FragColor = vec4(uv.x, uv.x, uv.x, 1.0);\r\n  gl_FragColor = texture2D( uniTexture, uvColor );\r\n  // Check death date.  Because .5 seconds before the  death, the moon\r\n  // turns orange.  \r\n  if( varDeath > uniFTime ) {\r\n    gl_FragColor = mix(ORANGE, gl_FragColor, clamp(2.0 * (varDeath - uniFTime), .0, 1.0));\r\n  }\r\n\r\n  // Now, we want  to compute normals to apply lighting effects.\r\n  vec2 uvNormal = .5 * uv + vec2(.5, .0);\r\n  vec3 normal = texture2D( uniTexture, uvNormal ).xyz;\r\n  normal = 2.0 * ( normal - vec3(.5, .5, .5) );\r\n  \r\n  lat = -asin( normal.y );\r\n  r = cos( lat );\r\n  lng = 0.0;\r\n  if( r > 0.0 ) {\r\n    lng = asin( normal.x / r );\r\n  }\r\n  normal = vec3(x,y,z);\r\n  x = normal.x;\r\n  y = normal.y * cos(lat) + normal.z * sin(lat);\r\n  z = -normal.y * sin(lat) + normal.z * cos(lat);\r\n  normal = vec3(x,y,z);\r\n  \r\n  // Shadow. (x,y,z) is the normal and (X,Y,Z) is the light ray.\r\n  vec3 light = reflect( vec3(X, Y, Z), normal );\r\n  //light = reflect( light, normal );\r\n  float shadow = -light.z;\r\n  if( shadow > 0.0 ) gl_FragColor = mix( gl_FragColor, WHITE, shadow );\r\n  else if( shadow < 0.0 ) gl_FragColor = mix( gl_FragColor, BLACK, -shadow );\r\n\r\n  gl_FragColor.a = alpha;\r\n}\r\n",vertSmoke:"#include vertCommon\n#include game2gl  \n\n// Vertex position and texture coords.\n// (x,y) for vertex position, in game's space.\n// z: birth.\n// w: random.\nattribute vec4 attPos;\n// Used for collisions. Smoke become dark after a collision.\n// Then attLight fall to zero.\nattribute float attLight;\n\nvarying float varLight;\nvarying float varAge;\n\nconst float CURVATURE = 0.5;\n\nvoid main() {\n  // Propagate random to the fragment shader.\n  varLight = attLight;\n  \n  // Point's size...\n  float age = uniVTime - attPos.z;\n  varAge = age;\n  float size = uniScrH * .05 * (1.0 + attPos.w);\n  size *= clamp( age, 0.0, 1.0 );\n  size += 30.0;\n  if( age > 2.0 ) size = 0.0;\n  gl_PointSize = size;\n\n  // Game's space coords.\n  float x = attPos.x - 40.0;\n  float shift = (age - 0.5) * 20.0;\n  shift *= shift;\n  shift -= 130.0;\n  float y = attPos.y + shift;\n  vec2 point = game2gl( x, y );\n  // GL has a square space with coords between -1 and +1.\n  // Final position in GL space.\n  gl_Position = vec4( point, 0.0, 1.0 );\n}\n",fragSmoke:"precision mediump float;\n\nuniform float uniFTime;\nuniform float uniCollision;\n\nvarying float varLight;\nvarying float varAge;\n\nvoid main() {\n  float x = gl_PointCoord.x - .5;\n  float y = gl_PointCoord.y - .5;\n  float r = sqrt(x*x + y*y);\n  if( r > 0.5 ) gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n    float a = 2.0 - varAge;\n    a = clamp(a, 0.0, 1.0);\n    a *= 1.0 - 2.0 * r;\n    float k = varLight;\n    gl_FragColor = vec4(k, k, k, 0.25 * a);\n  }\n}\n",vertStars:"#include vertCommon\n\n// Vertex position and texture coords.\n// (x,y,z) for vertex position, in game's space.\n// w: random.\nattribute vec4 attPos;\n\nvarying float varZ;\nvarying float varRnd;\n\nvoid main() {\n  // Propagate random to the fragment shader.\n  varZ = attPos.z;\n  varRnd = attPos.w;\n  \n  float factorS = uniScrH / uniGameH;\n  gl_PointSize = uniGameH * .08 * varZ * factorS;\n\n  // Game's space coords.\n  float xG = uniGameW * .5 - mod(attPos.x + uniCamX * varZ, uniGameW);\n  float yG = attPos.y - uniGameH * .5;\n\n  // Convert game coords into screen coords.\n  // A column must fit entirely in the screens height.\n  float xS = xG * factorS;\n  float yS = yG * factorS;\n  // Now, convert screen coords into WebGL coords.\n  // Setting the center.\n  float factorW = 2.0 / uniScrW;\n  float factorH = 2.0 / uniScrH;\n  float x = xS * factorW;\n  float y = yS * factorH;  \n\n  // GL has a square space with coords between -1 and +1.\n  // Final position in GL space.\n  gl_Position = vec4( x, y, 0.0, 1.0 );\n}\n",fragStars:"precision mediump float;\n\nuniform float uniFTime;\n\nvarying float varZ;\nvarying float varRnd;\n\nvoid main() {\n  float x = gl_PointCoord.x - .5;\n  float y = gl_PointCoord.y - .5;\n  float a = uniFTime * (.5 + varRnd);\n  float xx = x * cos(a) + y * sin(a);\n  float yy = -x * sin(a) + y * cos(a);\n  float r = abs(xx*xx - yy*yy);\n  if( r > 0.01 ) gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n    gl_FragColor = vec4(1.0, 1.0 - varRnd * .5, varRnd, varZ * .5);\n  }\n}\n",vertExplo:"#include vertCommon\n#include game2gl  \n\n// Vertex position and texture coords.\n// (x,y) for vertex position, in game's space.\n// z: birth.\n// w: random.\nattribute vec4 attPos;\n\nvarying float varBirth;\n\nvoid main() {\n  float age = uniVTime - attPos.z;\n  if( age > 1.0 ) {\n    // After 1 second, explosion must not been drawn.\n    gl_PointSize = 0.0;\n    return;\n  }\n\n  // Propagate random to the fragment shader.\n  varBirth = attPos.z;\n  \n  // Point's size... Depending on age.\n  gl_PointSize = pointSize( attPos.w * (1.0 + 2.0 * age) );\n\n  // Game's space coords.\n  vec2 point = game2gl( attPos.x, attPos.y );\n  // GL has a square space with coords between -1 and +1.\n  // Final position in GL space.\n  gl_Position = vec4( point, 0.0, 1.0 );\n}\n",fragExplo:"precision mediump float;\n\nuniform float uniFTime;\n\nvarying float varBirth;\n\nvoid main() {\n  float age = uniFTime - varBirth;\n\n  float x = gl_PointCoord.x - .5;\n  float y = gl_PointCoord.y - .5;\n  float r = 4.0 * sqrt(x*x + y*y);\n  float alpha = 0.0;\n  if( r < 1.0 ) {\n    alpha = sin( r * 20.0 + uniFTime * 5.0 );\n    alpha = abs( alpha );\n    alpha = .5 * alpha + .5;\n    alpha *= 1.0 - age;\n  }\n  gl_FragColor = vec4(1.0, 0.5, 0.0, alpha);\n}\n",game2gl:"vec2 game2scr(float xG, float yG) {\n  // Where the camera points, the coords are (0,0).\n  xG -= uniCamX;\n  yG -= uniCamY;\n  // Wrapping.\n  if( xG < -.25 * uniGameW ) xG += uniGameW;\n  else if( xG > .75 * uniGameW ) xG -= uniGameW;\n\n  // Convert game coords into screen coords.\n  // A column must fit entirely in the screens height.\n  float factorS = uniScrH / uniGameH;\n  float xS = xG * factorS - uniScrW * .25;\n  float yS = yG * factorS;\n\n  return vec2(xS, yS);\n}\n\nvec2 game2gl(float xG, float yG) {\n  vec2 scr = game2scr(xG, yG);\n  // Now, convert screen coords into WebGL coords.\n  // Setting the center.\n  float factorW = 2.0 / uniScrW;\n  float factorH = 2.0 / uniScrH;\n  float x = scr.x * factorW;\n  float y = scr.y * factorH;  \n\n  return vec2( x, y );\n}\n\n\nvec2 game2gl(vec2 pos) {\n  return game2gl( pos.x, pos.y );\n}\n\n\nfloat pointSize( float radius ) {\n  float factorS = uniScrH / uniGameH;\n  return 2.0 * radius * factorS;\n}\n\nvec2 wrap(vec2 pos) {\n  // Wrapping.\n  if( pos.x < -uniGameW ) pos.x += uniGameW;\n  if( pos.x > uniGameW ) pos.x -= uniGameW;\n  return pos;\n}\n",vertCommon:"const float PI = 3.141592653589793;\n\n// Time in seconds.\nuniform float uniVTime;\n// Screen dimensions in pixels.\nuniform float uniScrW;\nuniform float uniScrH;\n// Game's space dimension.\nuniform float uniGameW;\nuniform float uniGameH;\n// Where is the camera pointing?\nuniform float uniCamX;\nuniform float uniCamY;\n"},r=n("tfw.webgl");o.exports=function(n,o){var a=t["vert"+o];if(!a)throw Error("Vertex shader not found: vert"+o+"!");var e=t["frag"+o];if(!e)throw Error("Fragment shader not found: frag"+o+"!");return new r.Program(n,{vert:a,frag:e},t)},o.exports._=e});
//# sourceMappingURL=programs.js.map
require("hero",function(n,r,t){var e,o,i,u,a,f,c,l,A,s,_=function(){function r(){return e(t,arguments)}var t={en:{},fr:{}},e=n("$").intl;return r.all=t,r}(),h=n("global"),R=n("random"),m=n("programs"),v=n("image-loader"),C=n("event-handler"),d=Math.PI,L=2*h.COL_W,M=0,b=null,F=0;t.ready=new Promise(function(n,r){v({hero:"hero.png"}).then(function(r){i=r.hero,n()})}),t.start=function(){M=600},t.reset=function(n){b||(b=n,o=b.createBuffer(),u=m(b,"Hero")),e=new Float32Array(16),s=0,a=h.NB_COLS*h.COL_W*.5,f=.5*h.COL_H,c=0,l=0,A=h.COL_H/16,F=-666,C.on(function(n){l=777*n}),C.start()},t.draw=function(n){b.blendFunc(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA),h.setGlobalUniforms(u,n),u.$uniCollision=F,e[0]=a,e[1]=f,e[2]=A,e[3]=.25*d,e[4]=a,e[5]=f,e[6]=A,e[7]=.75*d,e[8]=a,e[9]=f,e[10]=A,e[11]=1.25*d,e[12]=a,e[13]=f,e[14]=A,e[15]=1.75*d;var r=l>0?Math.sqrt(l):-Math.sqrt(-l);r*=.02,r=Math.min(.5*d,Math.max(.5*-d,r)),u.$uniRotation=r,b.bindBuffer(b.ARRAY_BUFFER,o),b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW),b.enableVertexAttribArray(u.$attPos),b.vertexAttribPointer(u.$attPos,4,b.FLOAT,!1,4*h.BPE,0),b.drawArrays(b.TRIANGLE_FAN,0,4)},t.move=function(n){if(0==s)return void(s=n);var r=n-s;s=n,a+=c*r,c<L&&(c=Math.min(L,c+M*r*(c<0?4:1))),l>0?(l-=1600*r)<0&&(l=0):l<0&&(l+=1600*r)>0&&(l=0),f+=l*r,f>h.GAME_H-A?(f=h.GAME_H-A,l=l<0?l:-l):f<A&&(f=A,l=l>0?l:-l)},t.collision=function(n,r){c<0||(F=n,l+=(r<0?1:-1)*R()*1200,c=c<0?c:-c)},t.collisionTime=function(){return F},t.isInCollision=function(n){return n-F<1},t.x=function(){return a},t.y=function(){return f},t.vx=function(){return c},t.vy=function(){return l},t.size=function(){return A},r.exports._=_});
//# sourceMappingURL=hero.js.map
require("random",function(r,n,t){var e=function(){function n(){return e(t,arguments)}var t={en:{},fr:{}},e=r("$").intl;return n.all=t,n}();n.exports=Math.random,n.exports._=e});
//# sourceMappingURL=random.js.map
require("global",function(n,e,i){function r(n,i){Object.defineProperty(e.exports,n,{value:i,writable:!1,configurable:!0,enumerable:!0})}var a=function(){function e(){return r(i,arguments)}var i={en:{},fr:{}},r=n("$").intl;return e.all=i,e}();r("BPE",(new Float32Array).BYTES_PER_ELEMENT),r("COL_W",512),r("COL_H",1024),r("NB_COLS",16),r("GAME_W",i.NB_COLS*i.COL_W),r("GAME_H",i.COL_H),i.cameraX=0,i.cameraY=0,i.setGlobalUniforms=function(n,e){n.use(),n.$uniVTime=e,n.$uniFTime=e;var r=window.innerHeight>800?1:0;n.$uniScrW=window.innerWidth>>r,n.$uniScrH=window.innerHeight>>r,n.$uniGameW=i.GAME_W,n.$uniGameH=i.GAME_H,n.$uniCamX=i.cameraX,n.$uniCamY=i.cameraY},e.exports._=a});
//# sourceMappingURL=global.js.map
require("explo",function(r,e,n){var t,a,o,A=function(){function e(){return t(n,arguments)}var n={en:{},fr:{}},t=r("$").intl;return e.all=n,e}(),u=r("global"),f=(r("random"),r("programs")),i=null,l=0;n.ready=new Promise(function(r,e){r()}),n.reset=function(r){i||(i=r,a=i.createBuffer(),o=f(i,"Explo")),t=new Float32Array(24),a=i.createBuffer()},n.draw=function(r){i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ZERO,i.ONE),i.blendEquation(i.FUNC_ADD),u.setGlobalUniforms(o,r),i.bindBuffer(i.ARRAY_BUFFER,a),i.bufferData(i.ARRAY_BUFFER,t,i.STATIC_DRAW);var e=4*u.BPE;i.enableVertexAttribArray(o.$attPos),i.vertexAttribPointer(o.$attPos,4,i.FLOAT,!1,e,0),i.drawArrays(i.POINTS,0,6)},n.newExplosion=function(r,e,n,a){var o;o=4*l,t[o++]=r,t[o++]=e,t[o++]=n,t[o++]=2*a,l=(l+1)%6},e.exports._=A});
//# sourceMappingURL=explo.js.map
require("stars",function(r,e,t){var n,a,A,o=function(){function e(){return n(t,arguments)}var t={en:{},fr:{}},n=r("$").intl;return e.all=t,e}(),f=r("global"),u=r("random"),i=r("programs"),_=null;t.ready=new Promise(function(r,e){r()}),t.reset=function(r){_||(_=r,a=_.createBuffer(),A=i(_,"Stars")),n=new Float32Array(320),a=_.createBuffer();for(var e=0,t=0;t<80;t++)n[e++]=f.GAME_W*u(),n[e++]=f.GAME_H*u(),n[e++]=.25+.5*u(),n[e++]=u()},t.draw=function(r){_.blendFunc(_.SRC_ALPHA,_.ONE_MINUS_SRC_ALPHA),_.blendFuncSeparate(_.SRC_ALPHA,_.ONE_MINUS_SRC_ALPHA,_.ZERO,_.ONE),_.blendEquation(_.FUNC_ADD),f.setGlobalUniforms(A,r),_.bindBuffer(_.ARRAY_BUFFER,a),_.bufferData(_.ARRAY_BUFFER,n,_.STATIC_DRAW);var e=4*f.BPE;_.enableVertexAttribArray(A.$attPos),_.vertexAttribPointer(A.$attPos,4,_.FLOAT,!1,e,0),_.drawArrays(_.POINTS,0,80)},e.exports._=o});
//# sourceMappingURL=stars.js.map
require("moon",function(t,e,r){function n(t,e,r){u.collision(e,r),a(t,e)}function a(t,e){o[t+5]=e+.5}var o,i,A,l,f=function(){function e(){return n(r,arguments)}var r={en:{},fr:{}},n=t("$").intl;return e.all=r,e}(),b=t("global"),_=t("random"),u=t("hero"),v=t("explo"),O=t("programs"),L=t("image-loader"),C=navigator.vibrate||navigator.webkitVibrate||navigator.mozVibrate||function(){},S=null,c=-555;r.ready=new Promise(function(t,e){L({moon:"moon.png"}).then(function(e){l=e.moon,t()})}),r.reset=function(t){S||(S=t,i=S.createBuffer(),A=O(S,"Moon")),o=new Float32Array(6*b.NB_COLS),i=S.createBuffer();for(var e=0,r=0;r<b.NB_COLS;r++)o[e++]=0,o[e++]=0,o[e++]=0,o[e++]=0,o[e++]=0,o[e++]=0},r.draw=function(t){S.blendFunc(S.SRC_ALPHA,S.ONE_MINUS_SRC_ALPHA),S.blendFuncSeparate(S.SRC_ALPHA,S.ONE_MINUS_SRC_ALPHA,S.ZERO,S.ONE),S.blendEquation(S.FUNC_ADD),b.setGlobalUniforms(A,t),S.bindBuffer(S.ARRAY_BUFFER,i),S.bufferData(S.ARRAY_BUFFER,o,S.STATIC_DRAW);var e=6*b.BPE;S.enableVertexAttribArray(A.$attPos),S.vertexAttribPointer(A.$attPos,2,S.FLOAT,!1,e,0*b.BPE),S.enableVertexAttribArray(A.$attSize),S.vertexAttribPointer(A.$attSize,1,S.FLOAT,!1,e,2*b.BPE),S.enableVertexAttribArray(A.$attRnd1),S.vertexAttribPointer(A.$attRnd1,1,S.FLOAT,!1,e,3*b.BPE),S.enableVertexAttribArray(A.$attRnd2),S.vertexAttribPointer(A.$attRnd2,1,S.FLOAT,!1,e,4*b.BPE),S.enableVertexAttribArray(A.$attDeath),S.vertexAttribPointer(A.$attDeath,1,S.FLOAT,!1,e,5*b.BPE),S.drawArrays(S.POINTS,0,b.NB_COLS)},r.move=function(t){for(var e,r=0,a=0;a<b.NB_COLS;a++)e=o[r+5],e>0&&t>e&&(v.newExplosion(o[r],o[r+1],t,o[r+2]),o[r+1]=-1e4,o[r+2]=0,o[r+5]=0,C(200)),r+=6;if(!u.isInCollision(t)){var i=u.x(),A=u.y(),l=Math.floor(i/b.COL_W);if(l!=c){c=l;var f=l%b.NB_COLS,O=l*b.COL_W,L=Math.ceil(.6*b.NB_COLS),S=(f+L)%b.NB_COLS,r=6*S,B=b.COL_H/12*(.7+.6*_());o[r++]=O+(L+_())*b.COL_W,o[r++]=A+2*B*(_()-.5),o[r++]=B,o[r++]=_(),o[r++]=_(),o[r++]=0}var d,s,P,N,R=Math.floor(i/b.COL_W)%b.NB_COLS,m=(R+b.NB_COLS-1)%b.NB_COLS,x=(R+1)%b.NB_COLS,E=6*m,F=6*R,g=6*x;return s=o[E+0]-i,(P=o[E+1]-A,N=u.size()+o[E+2],(d=s*s+P*P)<N*N)?void n(E,t,P):(s=o[F+0]-i,P=o[F+1]-A,N=u.size()+o[F+2],(d=s*s+P*P)<N*N?void n(F,t,P):(s=o[g+0]-i,P=o[g+1]-A,N=u.size()+o[g+2],d=s*s+P*P,d<N*N?void n(g,t,P):void 0))}},r.makeTerrain=function(t){var e=document.createElement("canvas");e.setAttribute("width",256),e.setAttribute("height",256);var r=e.getContext("2d");r.fillStyle="rgb(127, 127, 255)",r.fillRect(0,0,256,256);for(var n,a,o,i,A,l=0;l<13;l++)for(o=8*_()+16,n=_()*(192-o)+64,a=_()*(192-o)+64,i=-1;i<2;i++)for(A=-1;A<2;A++)r.drawImage(t,n+256*i,a+256*A,.5*o,o);return e},e.exports._=f});
//# sourceMappingURL=moon.js.map
require("alert",function(e,n,t){function o(e){32!=e.keyCode&&13!=e.keyCode||r()}function d(){r()}function r(){c&&(c.className="alert",document.body.removeEventListener("keyup",o),document.body.removeEventListener("touchend",d),window.setTimeout(function(){c&&(document.body.removeChild(c),c=null,"function"==typeof u&&u())},300))}var u,i=function(){function n(){return o(t,arguments)}var t={en:{},fr:{}},o=e("$").intl;return n.all=t,n}(),c=null;n.exports=function(e,n){u=n;var t=document.body;c&&t.removeChild(c),c=document.createElement("div"),c.className="alert show";var r=document.createElement("div");r.innerHTML=e,c.appendChild(r),t.appendChild(c),t.addEventListener("keyup",o,!0),t.addEventListener("touchend",d,!0)},n.exports._=i});
//# sourceMappingURL=alert.js.map
require("offline",function(e,r,n){var o=function(){function r(){return o(n,arguments)}var n={en:{},fr:{}},o=e("$").intl;return r.all=n,r}();navigator.serviceWorker&&(navigator.serviceWorker.register("offline.js",{scope:"/space-adventure/"}),navigator.serviceWorker.ready.then(function(e){console.info("Service Worker is ready for ",e.scope)}).catch(function(e){console.error("Registration failed with: ",e)})),r.exports._=o});
//# sourceMappingURL=offline.js.map
