/** @module programs */require( 'programs', function(require, module, exports) { var _=function(){var D={"en":{},"fr":{}},X=require("$").intl;function _(){return X(D,arguments);}_.all=D;return _}();
 var GLOBAL = {
  "vertHero": "#include vertCommon\r\n#include game2gl  \r\n\r\n// Rotation in radians.\r\nuniform float uniRotation;\r\n\r\n// Vertex position and texture coords.\r\n// (x,y) for vertex position, in game's space.\r\n// (z,w) for (radius,angle).\r\nattribute vec4 attPos;\r\n\r\nvarying vec2 varUV;\r\n\r\nconst float SQRT2 = 1.4142135623730951;\r\n\r\nvoid main() {\r\n  float xG = attPos.x;\r\n  float yG = attPos.y;\r\n  // Diagonals must be multiplied by the square root of two.\r\n  float radius = attPos.z * SQRT2;\r\n  // Using the angle, we can deduce the corner position.\r\n  float angle = attPos.w;\r\n  // Propagate UV to the fragment shader.\r\n  varUV = vec2( .5 * SQRT2 * cos(angle) + .5,\r\n                .5 - .5 * SQRT2 * sin(angle) );\r\n  // Apply hero's self rotation.\r\n  angle += uniRotation;\r\n  // Adding some deformations due to \"Infinite Improbability Drive\".\r\n  angle *= 1.0 + .03 * cos(.6 * uniVTime * (.777+angle));\r\n  // Coords of this corner.\r\n  vec2 point = game2gl( xG + radius * cos(angle), yG + radius * sin(angle) );\r\n  \r\n  // GL has a square space with coords between -1 and +1.\r\n  // Final position in GL space.\r\n  gl_Position = vec4( point, 0.0, 1.0 );\r\n}\r\n",
  "fragHero": "precision mediump float;\r\n// Current time.\r\nuniform float uniFTime;\r\n// Last collision time.\r\nuniform float uniCollision;\r\n// The texture is the hero image.\r\nuniform sampler2D uniTexture;\r\n// texture coords UV between 0 and +1.\r\nvarying vec2 varUV;\r\n\r\nvoid main() {\r\n  gl_FragColor = texture2D( uniTexture, .5 * varUV );\r\n  float collision = uniFTime - uniCollision;\r\n  if( collision < 1.0 ) {\r\n    gl_FragColor.g *= collision;\r\n    gl_FragColor.b *= collision;\r\n  }\r\n}\r\n",
  "vertMoon": "#include vertCommon\r\n#include game2gl\r\n  \r\n// Vertex position and texture coords.\r\n// (x,y) for vertex position, in game's space.\r\n// (z,w) for (u,v) texture coords.\r\nattribute vec2 attPos;\r\n// Point size.\r\nattribute float attSize;\r\nattribute float attRnd1;\r\nattribute float attRnd2;\r\n\r\nvarying float varSize;\r\nvarying float varRnd1;\r\nvarying float varRnd2;\r\n\r\n\r\nvoid main() {\r\n  // Propagate size to the fragment shader.\r\n  varSize = attSize;\r\n  varRnd1 = attRnd1;\r\n  varRnd2 = attRnd2;\r\n  // Game's space coords.\r\n  vec2 point = game2gl( attPos );\r\n  // GL has a square space with coords between -1 and +1.\r\n  // Final position in GL space.\r\n  gl_Position = vec4( point, 0.0, 1.0 );\r\n    \r\n  // Point's size...\r\n  gl_PointSize = pointSize( attSize );\r\n}\r\n",
  "fragMoon": "precision mediump float;\r\n\r\nconst float PI = 3.141592653589793;\r\n\r\nconst float X = .5;\r\nconst float Y = -.5;\r\nconst float Z = 0.7071067811865476;\r\n\r\nconst vec4 WHITE = vec4( 1.0, 1.0, 1.0, 1.0 );\r\nconst vec4 BLACK = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\nuniform float uniFTime;\r\n\r\n// The texture is the hero image.\r\nuniform sampler2D uniTexture;\r\n\r\nvarying float varSize;\r\nvarying float varRnd1;\r\nvarying float varRnd2;\r\n\r\n\r\nvoid main() {\r\n  // Vector (x,y,z) has its tail at the center of the sphere and its head on the surface of the sphere.\r\n  float x = gl_PointCoord.x * 2.0 - 1.0;\r\n  float y = gl_PointCoord.y * 2.0 - 1.0;\r\n  float radius = x*x + y*y;\r\n  if( radius > 1.0 ) {\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  if( radius > .8 ) {\r\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.5);\r\n    return;\r\n  }\r\n  // Therefore, the length of the (x,y,z) vector must be 1 and x*x + y*y + z*z = 1.\r\n  float z = sqrt( 1.0 - x*x - y*y );\r\n  // Rotation.\r\n  float a = uniFTime * .5 * (.2 + varRnd1);\r\n  float x1 = x;\r\n  float y1 = y * cos(a) + z * sin(a);\r\n  float z1 = -y * sin(a) + z * cos(a);\r\n  a = uniFTime * .5 * (.2 + varRnd2);\r\n  float x2 = x1 * cos(a) + z1 * sin(a);\r\n  float y2 = y1;\r\n  float z2 = -x1 * sin(a) + z1 * cos(a);\r\n  \r\n  gl_FragColor = vec4( .6, .3, .0, 1.0 );\r\n\r\n  vec3 normal = texture2D( uniTexture, vec2(.25 * x2 + .75, .25 * y2 + .25) ).xyz;\r\n  normal = 2.0 * ( normal - vec3(.5, .5, .5) );\r\n  \r\n  float lat = -asin( normal.y );\r\n  float r = cos( lat );\r\n  float lng = 0.0;\r\n  if( r > 0.0 ) {\r\n    lng = asin( normal.x / r );\r\n  }\r\n  normal = vec3(x,y,z);\r\n  x = normal.x;\r\n  y = normal.y * cos(lat) + normal.z * sin(lat);\r\n  z = -normal.y * sin(lat) + normal.z * cos(lat);\r\n  normal = vec3(x,y,z);\r\n  \r\n  // Shadow. (x,y,z) is the normal and (X,Y,Z) is the light ray.\r\n  vec3 light = reflect( vec3(X, Y, Z), normal );\r\n  //light = reflect( light, normal );\r\n  float shadow = -light.z;\r\n  if( shadow > 0.0 ) gl_FragColor = mix( gl_FragColor, WHITE, shadow );\r\n  else if( shadow < 0.0 ) gl_FragColor = mix( gl_FragColor, BLACK, -shadow );\r\n}\r\n",
  "vertSmoke": "#include vertCommon\r\n#include game2gl  \r\n\r\n// Vertex position and texture coords.\r\n// (x,y) for vertex position, in game's space.\r\n// z: birth.\r\n// w: random.\r\nattribute vec4 attPos;\r\n// Used for collisions. Smoke become dark after a collision.\r\n// Then attLight fall to zero.\r\nattribute float attLight;\r\n\r\nvarying float varLight;\r\nvarying float varAge;\r\n\r\nconst float CURVATURE = 0.5;\r\n\r\nvoid main() {\r\n  // Propagate random to the fragment shader.\r\n  varLight = attLight;\r\n  \r\n  // Point's size...\r\n  float age = uniVTime - attPos.z;\r\n  varAge = age;\r\n  float size = uniScrH * .05 * (1.0 + attPos.w);\r\n  size *= clamp( age, 0.0, 1.0 );\r\n  size += 30.0;\r\n  if( age > 2.0 ) size = 0.0;\r\n  gl_PointSize = size;\r\n\r\n  // Game's space coords.\r\n  float x = attPos.x - 40.0;\r\n  float shift = (age - 0.5) * 20.0;\r\n  shift *= shift;\r\n  shift -= 130.0;\r\n  float y = attPos.y + shift;\r\n  vec2 point = game2gl( x, y );\r\n  // GL has a square space with coords between -1 and +1.\r\n  // Final position in GL space.\r\n  gl_Position = vec4( point, 0.0, 1.0 );\r\n}\r\n",
  "fragSmoke": "precision mediump float;\r\n\r\nuniform float uniFTime;\r\nuniform float uniCollision;\r\n\r\nvarying float varLight;\r\nvarying float varAge;\r\n\r\nvoid main() {\r\n  float x = gl_PointCoord.x - .5;\r\n  float y = gl_PointCoord.y - .5;\r\n  float r = sqrt(x*x + y*y);\r\n  if( r > 0.5 ) gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n  else {\r\n    float a = 2.0 - varAge;\r\n    a = clamp(a, 0.0, 1.0);\r\n    a *= 1.0 - 2.0 * r;\r\n    float k = varLight;\r\n    gl_FragColor = vec4(k, k, k, 0.25 * a);\r\n  }\r\n}\r\n",
  "game2gl": "vec2 game2scr(float xG, float yG) {\r\n  // Where the camera points, the coords are (0,0).\r\n  xG -= uniCamX;\r\n  yG -= uniCamY;\r\n  // Wrapping.\r\n  if( xG < -.25 * uniGameW ) xG += uniGameW;\r\n  else if( xG > .75 * uniGameW ) xG -= uniGameW;\r\n\r\n  // Convert game coords into screen coords.\r\n  // A column must fit entirely in the screens height.\r\n  float factorS = uniScrH / uniGameH;\r\n  float xS = xG * factorS - uniScrW * .25;\r\n  float yS = yG * factorS;\r\n\r\n  return vec2(xS, yS);\r\n}\r\n\r\nvec2 game2gl(float xG, float yG) {\r\n  vec2 scr = game2scr(xG, yG);\r\n  // Now, convert screen coords into WebGL coords.\r\n  // Setting the center.\r\n  float factorW = 2.0 / uniScrW;\r\n  float factorH = 2.0 / uniScrH;\r\n  float x = scr.x * factorW;\r\n  float y = scr.y * factorH;  \r\n\r\n  return vec2( x, y );\r\n}\r\n\r\n\r\nvec2 game2gl(vec2 pos) {\r\n  return game2gl( pos.x, pos.y );\r\n}\r\n\r\n\r\nfloat pointSize( float radius ) {\r\n  float factorS = uniScrH / uniGameH;\r\n  return 2.0 * radius * factorS;\r\n}\r\n\r\nvec2 wrap(vec2 pos) {\r\n  // Wrapping.\r\n  if( pos.x < -uniGameW ) pos.x += uniGameW;\r\n  if( pos.x > uniGameW ) pos.x -= uniGameW;\r\n  return pos;\r\n}\r\n",
  "vertCommon": "const float PI = 3.141592653589793;\r\n\r\n// Time in seconds.\r\nuniform float uniVTime;\r\n// Screen dimensions in pixels.\r\nuniform float uniScrW;\r\nuniform float uniScrH;\r\n// Game's space dimension.\r\nuniform float uniGameW;\r\nuniform float uniGameH;\r\n// Where is the camera pointing?\r\nuniform float uniCamX;\r\nuniform float uniCamY;\r\n"};
  /**
 * Manage all the shaders programs.
 */

"use strict";

var WebGL = require("tfw.webgl");


module.exports = function( gl, name ) {
    var vert = GLOBAL['vert' + name];
    if( !vert ) throw Error("Vertex shader not found: " + 'vert' + name + "!");
    var frag = GLOBAL['frag' + name];
    if( !frag ) throw Error("Fragment shader not found: " + 'frag' + name + "!");
    
    return new WebGL.Program(gl, {
        vert: vert,
        frag: frag
    }, GLOBAL);
};


  
module.exports._ = _;
/**
 * @module programs
 * @see module:$
 * @see module:tfw.webgl

 */
});